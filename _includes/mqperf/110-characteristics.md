
# Queue characteristics

On the **sender** side, we want to have a guarantee that if a message send call completes successfully, the message will be eventually processed. Of course, we will never get a 100% "guarantee", so we have to accept some scenarios in which messages will be lost, such as a catastrophic failure destroying all of our geographically distributed servers. Still, we want to minimise message loss. That’s why:

* messages should survive a restart of the server, that is messages should be *persisted* to a durable store (hard disk). However, we accept loosing messages due to unflushed disk buffers (we do not require `fsync`s to be done for each message).
* messages should survive a permanent failure of a server, that is messages should be *replicated* to other servers. We accept loosing messages which have been accepted, but haven’t yet been replicated (**asynchronous replication**). Some systems offer **synchronous replication** (message send call completes only after data is replicated), which of course is better, and additionally protects from message loss due to hard disk buffers not being flushed. We’ll make it clear later which systems offer what kind of replication. 

On the **receiver** side, we want to be able to receive a message and then acknowledge that the message was processed successfully. Note that receiving alone should not remove the message from the queue, as the receiver may crash at any time (including right after receiving, before processing). But that could also lead to messages being processed twice (e.g. if the receiver crashes after processing, before acknowledging); hence our queue should support *at least once delivery*.

With at-least-once-delivery, message processing should be _idempotent_, that is processing a message twice shouldn’t cause any problems. Once we assume that characteristic, a lot of things are simplified; message acknowledgments can be done asynchronously, as no harm is done if an ack is lost and the message re-delivered. We also don’t have to worry about distributed transactions. In fact, almost no system provides exactly-once delivery (even if it claims to - always read the fine print), it’s always a choice between at-most-once and at-least-once. However, the cost here is shifted to writing the message processing code appropriately. 