---
layout: default
title: Our presentations, videos and slides - SoftwareMill
description: Materials from presentations SoftwareMill members gave during various events and conferences, videos and slides.
---
<div id="baner-contact">
    <div class="wrapper"><span class="font-green">Videos and slides from our presentations</span></div>
</div>

<div class="support" id="presentations">
    <section>
        <div class="block">
            <div class="wrapper clearfix"><h2 class="light">2013</h2></div>
        </div>
        <div class="wrapper clearfix">
            <div class="text presentation-item">
                <p>
                    <p class= "presentation-title">Listen to the sounds of your application - Maciej Biłas & Krzysztof Ciesielski</p>
                    J-Day Krakow 2013, 16/11/2013,
                    <span class="tag-name">devops</span>
                    <span class="tag-name">graphite</span>
                    <span class="tag-name">logstash</span>
                    <span class="tag-name">monitoring</span>
                    <span class="tag-name">log analysis</span>
                    <span class="tag-name">metrics</span>
                    <span class="tag-name">kibana</span>
                <p>
                <p class="presentation-slideshare">
                    <iframe src="https://www.slideshare.net/slideshow/embed_code/28318940?rel=0" width="344" height="292"
                            frameborder="0" marginwidth="0" marginheight="0" scrolling="no"
                            style="border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px" allowfullscreen>
                    </iframe>
                </p>
                <p><strong>Abstract:</strong></p>
                <p class="presentation-abstract">
                    There are lots of valuable signals in our systems that we can capture and measure. Aside from
                    monitoring physical resources and latencies,
                    we can bring visibility to business data that we care about. We will present how to create a
                    monitoring and alerting stack which gives
                    a uniform view of those signals.<br/>
                    Given such setup we can detect anomalies or system failures or examine how our application usage
                    changes and plan our capacity in advance.
                    During this 30 minute talk we will try to convince you – the Java developer – why you should care
                    about applications metrics and logging
                    from early on in development.
                </p>
            </div>

            <div class="text presentation-item">
                <p>
                    <p class= "presentation-title">ElasticMQ: a fully asynchronous, Akka-based Amazon SQS server - Adam Warski</p>
                    Devoxx - Antwerp Belgium, 13/11/2013,
                    <span class="tag-name">scala</span>
                    <span class="tag-name">akka</span>
                    <span class="tag-name">spray</span>
                    <span class="tag-name">amazon sqs</span>
                <p>
                <p class="presentation-slideshare">
                    <iframe src="https://www.slideshare.net/slideshow/embed_code/28292398?rel=0" width="342" height="291"
                            frameborder="0" marginwidth="0" marginheight="0" scrolling="no"
                            style="border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px" allowfullscreen>
                    </iframe>
                </p>
                <p><strong>Abstract:</strong></p>
                <p class="presentation-abstract">
                    Amazon SQS is great if you need a simple message queueing system. Though when using SQS, it would be good
                    to test how our code integrates with it (for example if it correctly handles the visibility timeout or
                    queue creation parameters). Thus ElasticMQ was created: to provide an embeddable, in-memory SQS implementation.
                    <br/>
                    In the talk I will show how easy it is to run an embedded or stand-alone ElasticMQ server and test SQS client code,
                    both from JVM-based and non-JVM languages.
                    <br/>
                    The second part will be more technical; I will briefly explain how actors are used to handle queues, how to implement
                    long polling using futures, and how to write sequential-like code which in fact runs asynchronously using Akka Dataflow.
                    I will also demo some of the features of Spray, an Akka-based HTTP/REST toolkit, which make it easy to quickly create APIs.
                    <br/>
                    The project is fully open-source. You are encouraged to fork at: <a href="https://github.com/adamw/elasticmq">https://github.com/adamw/elasticmq</a>.
                </p>
            </div>

            <div class="text presentation-item">
                <p>
                    <p class= "presentation-title">The ideal module system and the harsh reality - Adam Warski</p>
                    Devoxx - Antwerp Belgium, 13/11/2013,
                    <span class="tag-name">scala</span>
                    <span class="tag-name">ceylon</span>
                    <span class="tag-name">veripacks</span>
                    <span class="tag-name">osgi</span>
                <p>
                <p class="presentation-slideshare">
                    <iframe src="https://www.slideshare.net/slideshow/embed_code/28292352?rel=0" width="342" height="291"
                            frameborder="0" marginwidth="0" marginheight="0" scrolling="no"
                            style="border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px" allowfullscreen>
                    </iframe>
                </p>
                <p><strong>Abstract:</strong></p>
                <p class="presentation-abstract">
                    I think most of us will agree that modularity is a Good Thing. However, while it is possible to create nice
                    modular applications, current languages do not offer a lot of tools that would make this task easier.
                    Hence we'll start by creating a (subjective) list of requirements for an "ideal" module system, just
                    to know how much more work is needed.
                    <br/>
                    Then we will take a look at Java packages. We usually think about packages in a hierarchical way, yet
                    they are treated by tools as simple identifiers. We use them for scoping, but Java only supports
                    package-private scope. We could use them as a module system, but we create build modules instead.
                    <br/>
                    I'd like to show two approaches to solving this problem. One is Veripacks, a Java/Scala library which
                    verifies transitive module-related annotations. Second is the module system in Ceylon, where modularity
                    is one of the main features of the language. I'll also compare with OSGi, and show how it differs.
                </p>
            </div>

            <div class="text presentation-item">
                <p>
                    <p class= "presentation-title">Suggestions for you: recommendations and Mahout - Adam Warski (in Polish)</p>
                    Warsaw Java User Group, 5/11/2013,
                    <span class="tag-name">mahout</span>
                    <span class="tag-name">recommendations</span>
                    <span class="tag-name">grouplens</span>
                    <span class="tag-name">graphlab</span>
                <p>
                <p class="presentation-slideshare">
                    <iframe src="https://www.slideshare.net/slideshow/embed_code/27941718?rel=0" width="342" height="291"
                            frameborder="0" marginwidth="0" marginheight="0" scrolling="no"
                            style="border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px" allowfullscreen>
                    </iframe>
                </p>
                <p>
                    <strong>
                        <a title="Polecane dla Ciebie: rekomendacje i Mahout - video"
                           href="http://www.youtube.com/watch?v=qS11WowjihE">Watch video</a>
                    </strong>
                </p>
                <p>&nbsp;</p>
                <p><strong>Abstract:</strong></p>
                <p class="presentation-abstract">
                    Sekcje "Wyjątkowe okazje dla Ciebie", "Użytkownicy, którzy kupili ten produkt kupili też ..." czy spersonalizowane
                    strony startowe w sklepach internetowych to już praktycznie standard. Implementacja systemów rekomendacji
                    była kiedyś zarezerwowana dla wyspecjalizowanych firm; dzisiaj mamy do dyspozycji parę open-sourcowych projektów,
                    takich jak Mahout czy LensKit, które ułatwiają wyciągać informacje z dużej ilości danych o preferencjach użytkowników.
                    <br/>
                    Po wprowadzeniu do systemów rekomendacji, czyli omówieniu podstawowych pojęć, możliwych postaci danych wejściowych
                    i klasyfikacji systemów ze względu na use-case'y przejdziemy do części praktycznej.
                    <br/>
                    Część praktyczna będzie obejmować głównie Apache Mahout (który opisuje się na stronie jako "Scalable machine learning
                    and data mining"). Mahout zawiera implementacje większości klasycznych algorytmów do obliczania rekomendacji; zobaczymy
                    jak w paru prostych krokach skonfigurować Mahouta i szybko otrzymać rekomendacje na podstawie własnych danych.
                </p>
            </div>

            <div class="text presentation-item">
                <p>
                <p class= "presentation-title">Visibility Shift in Distributed Teams - Paweł Wrzeszcz</p>
                Jazoon, Zurich, Switzerland, 22/10/2013
                <span class="tag-name">distributed agile</span>
                <span class="tag-name">collaboration culture</span>
                <span class="tag-name">remote work</span>
                <p>
                <p class="presentation-slideshare">
                    <iframe src="https://www.slideshare.net/slideshow/embed_code/27532868?rel=0" width="342" height="291"
                            frameborder="0" marginwidth="0" marginheight="0" scrolling="no"
                            style="border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px" allowfullscreen>
                    </iframe>
                </p>
                <p><strong>Abstract:</strong></p>
                <p class="presentation-abstract">
                    Contrary to common belief, distributed team can actually make it easier to adapt an agile approach to
                    software development. Compared with the co-located group, a distributed team experiences what I call
                    a shift in visibility. The hours spent in the office no longer count, therefore more focus is placed
                    on actual work done and business value delivered. If your team suffers from poor communication or
                    endless meetings, working remotely will make this even more conspicuous.
                    <br/>
                    This talk is based on my experience in working remotely for over 7 years in various environments,
                    which led me to believe that working in a distributed environment is like using Scrum - it does not
                    solve your problems, but makes them more visible.
                </p>
            </div>

            <div class="text presentation-item">
                <p>
                <p class= "presentation-title">Scala macros: what are they, how do they work & who uses them - Adam Warski</p>
                Javazone, Oslo, Norway, 12/09/2013
                <span class="tag-name">scala</span>
                <span class="tag-name">macros</span>
                <span class="tag-name">slick</span>
                <span class="tag-name">scalamock</span>
                <p>
                <p class="presentation-slideshare">
                    <iframe src="https://www.slideshare.net/slideshow/embed_code/26131216?rel=0" width="342" height="291"
                            frameborder="0" marginwidth="0" marginheight="0" scrolling="no"
                            style="border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px" allowfullscreen>
                    </iframe>
                </p>
                <p>
                    <strong>
                        <a title="Scala macros: what are they, how do they work & who uses them - video"
                           href="http://vimeo.com/74553075">Watch video</a>
                    </strong>
                </p>
                <p>&nbsp;</p>
                <p><strong>Abstract:</strong></p>
                <p class="presentation-abstract">
                    Macros are a brand new feature of Scala 2.10. In the presentation I would like to explain why were they added to the language,
                    show step by step how to write your own simple macro and show some libraries, which already use macros to implement functionalities,
                    which were not possible before.
                    <br/>
                    <a href="http://scalamacros.org/">Macros</a> are one of the new features in Scala 2.10. So far they are marked as experimental,
                    but I think nobody has doubts that they will stay there for good. Introducing macros was quite controversial, as Scala isn't
                    a "lean" language already, but I think it was worth it.
                    <br/>
                    Macro is simply a Scala program, executed at compile-time, which manipulates the AST of our program. While we probably will mostly
                    write macros when creating a library of a framework, rather than in day-to-day work (hopefully!), for sure it is good to know
                    what are the mechanisms behind them.
                    <br/>
                    In the presentation, I would firstly like to show step-by-step how to write a simple macro and how does it work. In the second part
                    I will present libraries, which already use macros (but without implementation details), such as <a href="http://scalamock.org/">ScalaMock</a>,
                    <a href="https://github.com/pniederw/expecty">Expecty</a>, <a href="http://slick.typesafe.com/">Slick</a>
                    or my own, <a href="https://github.com/adamw/macwire">MacWire</a>.
                </p>
            </div>
        </div>
    </section>


</div>
